02.10.2023


# Общее описание задания.
## 1. Описать собственный процессор:
    * архитектура (CISC, RISC);
    * разрядность;
    * регистры;
    * адресное пространство;
    * режимы адресации;
    * система команд;
    * формат машинных команд;
    * доступ к аппаратному обеспечению (проецирование видеобуфера и кода инициализации в память);
    * обработка прерываний (таймер, клавиатура);
    * состояние процессора (значения регистров) в момент запуска.
## 2. Создать язык ассемблера для этого процессора
    * мнемоники и синтаксис инструкций;
    * имена регистров;
    * механизмы сегментирования (код и данные);
    * выделение и инициализация памяти;
    * директивы ассемблера;
    * метки;
    * числовые типы данных;
    * представление строк и символов.
## 3. Написать ассемблер, реализующий созданный язык, на любом языке программирования.

## 4. Написать программу-эмулятор для разработанного процессора (на С/С++).

Эмулятор должен эмулировать монитор, доступный через запись в видеобуфер, клавиатуру и
системный таймер.

В эмуляторе должна запускаться программа, созданная написанным ассемблером.

В эмуляторе должна отображаться картинка с виртуального монитора, соответствующая текущему состоянию видеобуфера.



# Базовая функциональность 
К сдаче не принимаются задания с функциональностью меньше базовой.

15 баллов.

## Требования:

### 1. Система команд должна включать основные инструкции:
	* арифметические
	* логические
	* пересылки данных
	* битовые инструкции (побитовые логические, сдвиги, установка/получение битов)
	* условные переходы
	* безусловного перехода
	* вызов функции/возврат из функции
### 2) Инструкции должны кодироваться без явной избыточности. 
Например, не должны отводиться байты для кодирования отсутствующих у инструкции операндов.

### 3) Язык ассемблера должен предоставлять средства для именования адресов (метки, переменные, функции).

### 4) Система команд должна предоставлять как минимум два способа адресации:
    * адрес в регистре (общего назначения)
    * непосредственный адрес либо смещение относительно некоторого регистра

## 5) Написать на созданном ассемблере программу, демонстрирующую все реализованные функции.



# Полная функциональность

35 баллов

## Требования (дополнительно к базовым):

### 1) Система команд должна предоставлять следующие возможности:
    * получение нажатых клавиш (через прерывания)
    * периодические действия с заданным периодом (через прерывания)
    * получение случайных значений

### 2) Система команд дополнительно должна предоставлять способы адресации:
    * адрес получается как сумма двух регистров (общего назначения)
    * адрес получается как сумма двух регистров (общего назначения) плюс абсолютное значение

### 3) Инструкции должны кодироваться оптимальным способом. 

Например если в системе команд предусмотрено не более 32 инструкций, то для их кодирования отводится не более 5 бит, а оставшиеся в байте биты используются для кодирования чего-то другого.

### 4) Эмулятор должен предоставлять основные возможности отладки: 
    * точки останова, 
    * трассировку с заходом и без 
    * отображение памяти и регистров.

### 5) Реализовать простую графическую игру для запуска на эмуляторе. 
В игре должны быть взаимодействие с пользователем, периодическая функциональность (ответные действия) компьютера.


## Дополнительно.

3 балла.

### 6) Реализовать режим адресации при котором адрес может задаваться как сумма любого количества регистров (умноженных на произвольные константы) и константы.


# Указания и рекомендации
Необходимо определиться с архитектурой процессора (RISC, CISC, стековый процессор). Для RISC характерно большое количество равноправных регистров, простые инструкции и одинаковая длина машинных инструкций. CISC обычно имеют небольшое количество специализированных регистров, сложные инструкции, множество режимов адресации и разную длину машинных инструкций (для сокращения размера часто используемые инструкции кодируются меньшим количеством бит). Стековые процессор может быть как RISC так и CISC, только аргументы для инструкций (кроме, быть может, инструкции push) передаются через стек.

Обязательно должны быть регистры:

    * указатель инструкций
    * указатель стека
    * слово состояния процессора (регистр флагов)

Необходимо определиться с форматом выходного файла для ассемблера и входного для эмулятора. Это может быть сложный формат с файловым заголовком, определяющим адрес загрузки программы, адреса загрузки секции кода и данных, точку входа. Либо это может быть плоский файл без заголовка, содержащий код и данные вместе. Тогда программа всегда будет грузиться по фиксированному адресу.

Эмулятор при загрузке программы может копировать её в оперативную память, либо проецировать как это сделано для кода BIOS (т.е. обращения к определённому адресу приводят на самом деле к обращению не к оперативной памяти, а к ПЗУ). Адрес загрузки может быть фиксированным или определяться из файлового заголовка. 
Обращение к видеобуферу следует осуществлять с помощью его проецирования на определённый адрес, таким образом, что считывание или запись байта из оперативной памяти приводит к считыванию или записи байта видеобуфера. Для кодирования пикселя можно использовать 1 байт (256 доступных цветов). В таком случае, если разрешение виртуального монитора будет 480х320, размер видеобуфера будет 150 КБ. Можно реализовать возможность переключения видеобуфера на разные адреса, чтобы не перерисовывать картинку попикселям, а сначала сформировать всё изображение в памяти, а затем разом его перерисовать. Хранить видеобуфер в память можно стандартным образом построчно: первые 480 байт соответствуют пикселям первой строки и т.д.

В момент запуска программы регистры процессора должны быть инициализированы особым образом, чтобы программа могла исполниться, например указатель инструкций должен указывать на адрес загрузки программы.

Обработку клавиатуры и системного таймера осуществлять с помощью прерываний. Прерывания от таймера должны генерироваться с определённым интервалом (например, 1000 раз в секунду), а от клавиатуры - при нажатии клавиши. Адреса обработчиков прерываний должны устанавливать программой в момент запуска либо по фиксированным адресам, либо с помощью специальной инструкции, либо в специальных регистрах. Должна быть возможность блокировки прерываний (например с помощью флага в регистре флагов либо эмулировать контроллер прерываний с возможностью программного управления им). Если поступает прерывание в тот момент, когда прерывания заблокированы, вызов обработчика должен быть отложен до того момента, пока прерывания не будут разблокированы. Если за время ожидания поступит несколько прерываний должно быть обработано последнее из них (таким образом, могут быть потеряны все предыдущие нажатия клавиш). В момент инициализации прерывания должны быть заблокированы или должны быть установлены пустые обработчики по умолчанию. Прерывания от таймера позволяют выполнять повторяющиеся действия (например обновление игрового поля). При генерации прерывания в стеке должен сохраняться адрес возврата и вызываться обработчик прерывания. Обработчик прерывания должен сохранять все изменяемые регистры, чтобы восстановить их при выходе.
При вызове обработчика прерывания клавиатуры в стек или в определённый регист может помещаться код нажатой клавиши (это могут быть скан-коды настоящей клавиатуры, либо самостоятельно придуманные коды). Либо обработчик должен каким-либо другим образом получать код нажатой клавиши (например через порты ввода/вывода).


За основу можно взять эмулятор и ассемблер, предоставляемые вместе с заданием.
